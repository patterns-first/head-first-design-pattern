## 01 디자인 패턴의 세계로 떠나기 : 디자인 패턴 소개와 전략 패턴

디자인 패턴

- 개발자 사이에서 서로 모두 이해할 수 있는 용어를 제공
- 용어를 이해하고 나면 다른 개발자와 더 쉽게 대화할 수 있다.

# **전략 패턴 (Strategy Pattern)**

- 알고리즘군을 정의하고, 각각을 캡슐화하며, 이들을 교체해서 사용할 수 있게 만드는 패턴
- 전략 패턴을 사용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.

## **문제 상황**

### **오리 시뮬레이션 예시**

다양한 종류의 오리(MallardDuck, RedHeadDuck 등)를 만들고, 오리들이 날고, 꽥꽥거리고, 보여줌(display)

```tsx
class MallardDuck {
  quack() {
    console.log("Quack");
  }
  fly() {
    console.log("I'm flying");
  }
  display() {
    console.log("I'm a real Mallard duck");
  }
}

class RedHeadDuck {
  quack() {
    console.log("Quack");
  }
  fly() {
    console.log("I'm flying");
  }
  display() {
    console.log("I'm a real Red Headed duck");
  }
}
```

### **첫 번째 문제: RubberDuck 추가**

- 고무 오리는 날 수 없고, "삑삑" 소리를 낸다.

### **첫 번째 해결책: 상속**

```tsx
class Duck {
  quack() {
    console.log("Quack");
  }
  fly() {
    console.log("I'm flying");
  }
  abstract display();
}

class RubberDuck extends Duck {
  display() {
    console.log("I'm a rubber duck");
  }
  quack() {
    console.log("Squeak");
  } // 오버라이드
  fly() {
    console.log("I can't fly");
  } // 오버라이드
}
```

### **두 번째 문제: DecoyDuck 추가**

- 가짜 오리는 날 수도 없고, 소리도 내지 않는다.
- 하지만 코드가 중복됨

### **세 번째 문제: 날기 동적 변경**

모든 오리가 날 수 있는 것은 아니다.

상속으로 해결하면 코드가 중복되고 유지보수가 어렵다.

## **해결책**

### **두 번째 해결책: 인터페이스 분리**

인터페이스를 사용해서 동작을 캡슐화

```tsx
interface Flyable {
  fly(): void;
}

interface Quackable {
  quack(): void;
}

class MallardDuck implements Flyable, Quackable {
  fly() {
    /* ... */
  }
  quack() {
    /* ... */
  }
}
```

문제 발생

- 인터페이스에는 구현된 코드가 없어서 코드를 재사용할 수 없음
- 한 가지 행동을 바꿀 때마다 그 행동이 정의되어 있는 서로 다른 서브클래스를 전부 찾아서 코드를 일일이 고쳐야 함

### **세 번째 해결책: 전략 패턴**

행동을 클래스로 캡슐화하고, 오리 클래스에서 행동을 위임

## **패턴 구조**

### **클래스 다이어그램**

```
┌─────────────────────┐
│      Context        │
│   (Duck - 추상)      │
├─────────────────────┤
│ - flyBehavior       │──┐
│ - quackBehavior     │──┤
├─────────────────────┤  │
│ + performFly()      │  │
│ + performQuack()    │  │
│ + setFlyBehavior()  │  │
│ + setQuackBehavior()│  │
└─────────────────────┘  │
         ▲               │
         │               │
         │ implements    │
         │               │
┌─────────────────────┐  │    ┌──────────────────────┐
│  MallardDuck        │  │    │    Strategy          │
│  RedHeadDuck        │  │    │   (Interface)        │
│  ModelDuck          │  │    ├──────────────────────┤
│  DecoyDuck          │  │    │ + execute()          │
└─────────────────────┘  │    └──────────────────────┘
                         │              ▲
                         │              │
                         │              │
                         │    ┌─────────┴──────────┐
                         │    │                    │
┌─────────────────────┐  │    │                    │
│  FlyBehavior        │──┘    │                    │
│  (Interface)        │       │                    │
├─────────────────────┤       │                    │
│ + fly()             │       │                    │
└─────────────────────┘       │                    │
         ▲                    │                    │
         │                    │                    │
    ┌────┴──────┐             │                    │
    │           │             │                    │
┌───┴───┐   ┌───┴────┐        │                    │
│FlyWith│   │FlyNoWay │       │                    │
│ Wings │   │         │       │                    │
└───────┘   └─────────┘       │                    │
                            ┌─┴────────────────────┴──┐
                            │                         │
                     ┌──────┴────────┐           ┌────┴─────────┐
                     │               │           │              │
                ┌────┴─────┐    ┌────┴────┐  ┌───┴────┐   ┌─────┴────┐
                │   Quack  │    │MuteQuack│  │ Squeak │   │FakeQuack │
                └──────────┘    └─────────┘  └────────┘   └──────────┘
```

### **핵심 원칙**

1. 알고리즘군을 정의하고 각각을 캡슐화
2. 행동을 인터페이스로 추상화
3. 구체적인 행동을 별도의 클래스로 구현
4. 컨텍스트에서 행동 객체를 조합(Composition)
5. 런타임에 행동을 교체 가능

## **구현 예시**

### **1. 전략 인터페이스 정의**

```tsx
// 날기 전략 인터페이스
export interface FlyBehavior {
  fly(): void;
}

// 울기 전략 인터페이스
export interface QuackBehavior {
  quack(): void;
}
```

### **2. 구체적인 전략 구현**

```tsx
// 날기 전략 구현들
export class FlyWithWings implements FlyBehavior {
  fly(): void {
    console.log("I'm flying!!");
  }
}

export class FlyNoWay implements FlyBehavior {
  fly(): void {
    console.log("I can't fly");
  }
}

export class FlyRocketPowered implements FlyBehavior {
  fly(): void {
    console.log("I'm flying with a rocket");
  }
}

// 울기 전략 구현들
export class Quack implements QuackBehavior {
  quack(): void {
    console.log("Quack");
  }
}

export class MuteQuack implements QuackBehavior {
  quack(): void {
    console.log("<< Silence >>");
  }
}

export class Squeak implements QuackBehavior {
  quack(): void {
    console.log("Squeak");
  }
}

export class FakeQuack implements QuackBehavior {
  quack(): void {
    console.log("<< Fake quack sound >>");
  }
}
```

### **3. 컨텍스트 (Duck) 정의**

```tsx
export abstract class Duck {
  // 전략 객체 조합 (Composition)
  flyBehavior!: FlyBehavior;
  quackBehavior!: QuackBehavior;

  // 전략 설정 메서드
  setFlyBehavior(fb: FlyBehavior): void {
    this.flyBehavior = fb;
  }

  setQuackBehavior(qb: QuackBehavior): void {
    this.quackBehavior = qb;
  }

  // 전략 실행 위임
  performFly(): void {
    this.flyBehavior.fly();
  }

  performQuack(): void {
    this.quackBehavior.quack();
  }

  // 공통 메서드
  swim(): void {
    console.log("All ducks float, even decoys!");
  }

  // 추상 메서드
  abstract display(): void;
}
```

### **4. 구체적인 컨텍스트 구현**

```tsx
export class MallardDuck extends Duck {
  constructor() {
    super();
    // 생성 시점에 전략 설정
    this.quackBehavior = new Quack();
    this.flyBehavior = new FlyWithWings();
  }

  display(): void {
    console.log("I'm a real Mallard duck");
  }
}

export class RedHeadDuck extends Duck {
  constructor() {
    super();
    this.flyBehavior = new FlyWithWings();
    this.quackBehavior = new Quack();
  }

  display(): void {
    console.log("I'm a real Red Headed duck");
  }
}

export class RubberDuck extends Duck {
  constructor() {
    super();
    this.flyBehavior = new FlyNoWay();
    this.quackBehavior = new Squeak();
  }

  display(): void {
    console.log("I'm a rubber duck");
  }
}

export class DecoyDuck extends Duck {
  constructor() {
    super();
    this.setFlyBehavior(new FlyNoWay());
    this.setQuackBehavior(new MuteQuack());
  }

  display(): void {
    console.log("I'm a duck Decoy");
  }
}

export class ModelDuck extends Duck {
  constructor() {
    super();
    this.flyBehavior = new FlyNoWay();
    this.quackBehavior = new Quack();
  }

  display(): void {
    console.log("I'm a model duck");
  }
}
```

### **5. 사용 예시**

```tsx
export class MiniDuckSimulator1 {
  main(args: string[]): void {
    let mallard = new MallardDuck();
    mallard.performQuack(); // Quack
    mallard.performFly(); // I'm flying!!

    let model = new ModelDuck();
    model.performFly(); // I can't fly

    // 런타임에 전략 변경
    model.setFlyBehavior(new FlyRocketPowered());
    model.performFly(); // I'm flying with a rocket
  }
}
```

### **1. 전략 인터페이스**

**FlyBehavior.ts**

```tsx
export interface FlyBehavior {
  fly(): void;
}
```

- 단일 메서드만 가짐 (단일 책임 원칙)
- 구현을 포함하지 않음 (인터페이스의 역할)

**QuackBehavior.ts**

```tsx
export interface QuackBehavior {
  quack(): void;
}
```

### **2. 구체적 전략 구현**

**FlyWithWings.ts**

```tsx
export class FlyWithWings implements FlyBehavior {
  fly(): void {
    console.log("I'm flying!!");
  }
}
```

- `FlyBehavior` 인터페이스 구현
- 실제 날기 동작 구현

**FlyNoWay.ts**

```tsx
export class FlyNoWay implements FlyBehavior {
  fly(): void {
    console.log("I can't fly");
  }
}
```

- 같은 인터페이스를 구현하지만 다른 동작

**FlyRocketPowered.ts**

```tsx
export class FlyRocketPowered implements FlyBehavior {
  fly(): void {
    console.log("I'm flying with a rocket");
  }
}
```

- 새로운 전략을 추가해도 기존 코드 수정 불필요 (OCP 원칙)

### **3. 컨텍스트 (Duck 클래스)**

**Duck.ts**

```tsx
export abstract class Duck {
  flyBehavior!: FlyBehavior; // 전략 객체 포함
  quackBehavior!: QuackBehavior; // 전략 객체 포함

  setFlyBehavior(fb: FlyBehavior): void {
    this.flyBehavior = fb;
  }

  setQuackBehavior(qb: QuackBehavior): void {
    this.quackBehavior = qb;
  }

  performFly(): void {
    this.flyBehavior.fly(); // 전략에 위임
  }

  performQuack(): void {
    this.quackBehavior.quack(); // 전략에 위임
  }

  swim(): void {
    console.log("All ducks float, even decoys!");
  }

  abstract display(): void;
}
```

**특징:**

- `abstract class`: 인스턴스화 불가능
- 전략 객체를 조합(Composition)으로 가짐
- 전략 실행을 전략 객체에 위임(Delegation)
- `setFlyBehavior`, `setQuackBehavior`: 런타임에 전략 변경 가능

### **4. 구체적 컨텍스트**

**MallardDuck.ts**

```tsx
export class MallardDuck extends Duck {
  constructor() {
    super();
    this.quackBehavior = new Quack(); // 꽥꽥
    this.flyBehavior = new FlyWithWings(); // 날 수 있음
  }

  display(): void {
    console.log("I'm a real Mallard duck");
  }
}
```

- 생성자에서 전략 초기화
- 실제 오리의 특성 반영

**ModelDuck.ts**

```tsx
export class ModelDuck extends Duck {
  constructor() {
    super();
    this.flyBehavior = new FlyNoWay(); // 처음에는 날 수 없음
    this.quackBehavior = new Quack();
  }

  display(): void {
    console.log("I'm a model duck");
  }
}
```

### **5. 런타임 전략 변경**

**MiniDuckSimulator1.ts**

```tsx
export class MiniDuckSimulator1 {
  main(args: string[]): void {
    let mallard = new MallardDuck();
    mallard.performQuack(); // Quack
    mallard.performFly(); // I'm flying!!

    let model = new ModelDuck();
    model.performFly(); // I can't fly

    // 런타임에 전략 변경! ✨
    model.setFlyBehavior(new FlyRocketPowered());
    model.performFly(); // I'm flying with a rocket
  }
}
```

**출력:**

```
Quack
I'm flying!!
I can't fly
I'm flying with a rocket
```

---

## **장단점**

### **장점**

1. **개방-폐쇄 원칙 (OCP)**
   - 새로운 전략을 추가해도 기존 코드 수정 불필요
   - `FlyRocketPowered` 추가 시 `Duck` 클래스 수정 없음
2. **단일 책임 원칙 (SRP)**
   - 각 전략 클래스가 하나의 행동만 담당
   - 날기, 울기 등의 행동이 분리됨
3. **유연성**
   - 런타임에 알고리즘 교체 가능
   - `model.setFlyBehavior(new FlyRocketPowered())`
4. **코드 재사용성**
   - 동일한 전략을 여러 컨텍스트에서 재사용
   - `FlyWithWings`를 `MallardDuck`, `RedHeadDuck` 등에서 재사용
5. **상속보다 조합(Composition)**
   - "HAS-A" 관계(조합)가 "IS-A" 관계(상속)보다 유연함 : 코드를 변경하거나 확장할 때 더 쉽고 안전
   - 오리는 날기 행동을 "가짐" (상속이 아님)
6. **테스트 용이성**
   - 각 전략을 독립적으로 테스트 가능
   - Mock 전략으로 테스트 쉬움

### **단점**

1. **클래스 수 증가**
   - 각 전략마다 별도 클래스 필요
   - 작은 프로젝트에는 과도할 수 있음
2. **클라이언트가 적절한 전략 선택 필요**
   - 어떤 전략을 사용할지 알아야 함
   - 전략 선택 로직 필요
3. **컨텍스트와 전략 간 통신 오버헤드**
   - 컨텍스트가 전략에 데이터 전달 필요할 수 있음
   - 전략이 컨텍스트 상태에 접근 필요할 수 있음

## **사용 시점**

### **사용하면 좋은 경우**

1. **여러 알고리즘이 교체 가능해야 할 때**
   - 정렬 알고리즘 (퀵소트, 머지소트 등)
   - 압축 알고리즘 (ZIP, GZIP, LZMA 등)
2. **클라이언트가 알고리즘의 구현을 숨겨야 할 때**
   - 내부 구현 노출 없이 기능 제공
3. **클래스에 여러 변형된 행동이 있고, 이를 if-else로 처리하고 싶지 않을 때**
   - 대규모 if-else나 switch 문 제거
4. **알고리즘을 사용하는 데이터 구조와 알고리즘 자체를 분리하고 싶을 때**
   - 데이터와 알고리즘의 독립적 발전 가능
5. **런타임에 알고리즘을 선택해야 할 때**
   - 사용자 설정에 따른 동적 알고리즘 선택
