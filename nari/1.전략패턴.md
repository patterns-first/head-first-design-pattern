# SimUduck

Duck 이라는 슈퍼 클래스를 만듦
Duck에는 quack, swim, display 등 기타 오리 관련 메서드 존재

다양한 오리들이 Duck 클래스를 상속받아서 만들어짐.
display 메서드를 오버라이딩

# 오리 시뮬레이션 게임 차별화하기

- 오리가 날 수 있어야 한다는 추가 요구사항 발생
- Duck 이라는 슈퍼 클래스에 fly 메서드를 추가

# 문제 상황

- Duck의 일부 서브클래스만 날아다녀야 하고, 고무오리 같은 경우는 날면 안됨.

# 해결

- 안 날아다녀야 하는 오리 클래스의 경우는 fly 함수르 아무것도 하지 않도록 오버라이드

(여기 퀴즈에서 실행 시에 특징을 바꾸기 힘들다는 어떤 내용이지??)

# 인터페이스 설계하기

- fly 메서드를 슈퍼클래스에서 빼고, fly 메소드가 들어있는 Flyable 인터페이스를 만들 수 있음
- Quackable도 따로 인터페이스를 만들 수 있음

# 해결 방법 고민하기

- 하지만 위 설계도 문제가 있을 수 있음
- 서브클래스에서 Flyable, Quckable을 구현해서 일부 문제를 해결할 수 있지만 코드를 재사용하지 않으므로 코드 관리에 문제가 생김. (??이해가 안됨 어떤 코드 재사용이 안된다는거지)

# 소프트웨어를 고칠 때 ...

- 기존 코드에 미치는 영향을 줄이면서 작업할 수 있는 방법은 없을까??

# 소프트웨어 개발 불변의 진리

- 항상 바뀐다! 애플리케이션은 시간에 따라 변화하고 성장해야 한다.

# 문제를 명확하게 파악하기

- 상속이 그리 성공적인 해결책이 아님
- 서브 클래스마다 오리의 행동이 바뀔 수 있는데 모든 서브클래스에서 한 가지 행동만 사용하도록 하는 것은 올바르지 못함
- 한 가지 행동을 바꿀 떄마다 그 행동이 정의되어 있는 서로 다른 서브클래스를 전부 찾아 일일이 고쳐야 함.

- 디자인 원칙: 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
- 달라지지 않는 부분을 찾아서 나머지 부분에 영향을 주지 않도록 '캡슐화' 한다.
  그러면 코드를 변경하는 과정에서 의도치 않게 발생하는 일을 줄이며 시스템의 유연성을 향상 가능

=> 오리들의 행동을 Duck 클래스에서 뽑아 보기

# 바뀌는 부분과 그렇지 않은 부분 분리하기

- 바뀌는 부분 : fly, quack
- 바뀌지 않는 부분 : 나머지 Duck 클래스 구현부분

- 나는 것 관련, 꽥꽥거리는 것 관련 이렇게 2개의 클래스 집합을 만들어야 함.
- 각 클래스 집합에는 각각의 행동을 구현한 것을 전부 집어 넣음.

# 오리의 행동을 디자인하는 방법

- 나는 행동과 꽥꽥거리는 행동을 구현하는 클래스 집합의 디자인 방법?
  - 유연하게
  - Duck의 인스턴스에 행동을 할당할 수 있어야 함
    ex. MallardDuck 인스턴스를 새로 만들고 특정 형식의 나는 행동으로 초기화
  - Duck 클래스에 행동과 관련된 setter 메소드를 포함해서 프로그램 실행 중에도 MallardDuck의 나는 행동을 바꿀 수 있으면 좋음

# 두 번째 디자인 원칙

- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
- 각 행동은 인터페이스(FlyBehavior, QuackBehavior)로 표현하고, 이런 인터페이스를 사용해서 행동을 구현
- 이전의 방법은 특정 구현에 의존했기 대문에, 행동을 변경할 여지가 없었음.
- 새 디자인은 Duck 서브클래스는 인터페이스로 표현되는 행동을 사용하기 대문에 실제 행동 구현은 Duck 서브 클래스에 국한되지 않음.

FlyBehavior(fly())
-> FlyWithWings(fly()나는 방법 구현)
-> FlyNoWay(fly{// 아무것도 하지 않음 })

# 인터페이스에 맞춰서 프로그래밍 한다는 것?

- 사실 상위 형식에 맞춰서 프로그래밍 한다는 말
- 실제 실행 시에 쓰이는 객체가 코드에 고정되지 않도록 상위 형식(supertype)에 맞춰 프로그래밍해서 다형성을 활용해야 한다.
- 변수를 선언할 때 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 한다. 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 넣을 수 있기 때문이다.
- 또 상위 형식의 인스턴스를 만드는 과정을 (new Dog())같은 식으로 직접 코드로 만드는 대신 구체적으로 구현된 객체를 실행 시 대입하는 것이 더 바람직

```java
a = getAnimal();
a.makeSound();
```

# 오리 행동 통합하기

- 가장 중요한 점: Duck 클래스에서 나는 행동, 꽥꽥 거리는 행동을 다른 클래스에 위임

1. Duck 클래스에 flyBehavior, quackBehavior라는 인터페이스 형식의 인스턴스 변수 추가

- 각 오리 객체에서는 실행 시 이 변수에 특정 행동 형식의 레퍼런스를 다형적으로 설정
- Duck 클래스의 모든 서브클래스에서 fly, quack 메소드 제거
- Duck 클래스에 fly, quack 대신 performFly(), performQuack()이라는 메서드 추가

```java

FlyBehavior flyBehavior
QuackBehavior quackBehavior

performQuack()
swim()
display()
performFly()
// 기타 오리 관련 메서드
```

2. performQuack() 구현

- 꽥꽥거리는 행동을 하고 싶을 땐 quackBehavior에 의해 참조되는 객체에서 꽥꽥거리도록 하면 됨
- 객체의 종류에 신경 쓸 필요 없이 quack()실행

```java
public abstract class Duck {
  // 모든 Duck에는 QuackBehavior 인터페이스를 구현하는 것의 레퍼런스 존재 (??이게 무슨 말이지)
  QuackBehavior quackBehavior;
  // 기타 코드

  public void performQuack(){
    // 꽥꽥거리는 행동을 quackBehavior로 참조되는 객체에 그 행동을 위임
    quackBehavior.quack();
  }
}
```

3. flyBehavior과 quackBehavior 인스턴스 변수 설정 방법 생각해보기

- MallardDuck 클래스 살펴보기

```java
public class MallardDuck extends Duck {

  public MallardDuck(){
    // 말라드 덕의 꽥꽥거리는 행동을 처리할 때에는 Quack 클래스를 사용하므로 performQuack()이 호출되면 꽥꽥거리는 행동은 Quack 객체에게 위임
    quackBehavior = new Quack();
    // flybehavior는 FlyWithWings를 사용
    flyBehavior = new FlyWithWings();
  }

  public void display() {
    System.out.printIn('저는 물오리입니다');
  }
}
```

- 그런데 특정 구현에 맞춰서 프로그래밍 하면 안된다고 하지 않았나? Quack이라는 구현되어 있는 구상 클래스의 인스턴스를 만들었음 잘못되지 않았나? (??)

# 오리 코드 테스트

- skip

# 동적으로 행동 지정하기

- 오리의 행동 형식을 생성자에서 인스턴스를 만드는 방법(new Quack())이 아닌 Duck의 서브 클래스에서 세터 메소드를 호출하는 방법으로 설정
- Duck 클래스에 setFlyBehavior, setQuackBehavior 메서드 추가
- Duck의 서브클래스인 ModelDuck.java를 생성
- FlyBehavior의 형식 클래스 FlyRocketPowered.java를 새로 생성
- 테스트 클래스인 MiniDuckSimulator.java를 수정

```java
Duck model = new ModelDuck()
model.performFly(); // 처음 ModelDuck 인스턴스에 초기화된 상태
model.setFlyBehavior(new FlyRocketPowered()); //Flybehavior를 오버라이드
model.performFly(); // 로켓추진으로 날아감
```

# 캡슐화된 행동 살펴보기

- 오리들의 행동들을 일련의 행동으로 생각하는 대신, 알고리즘군으로 생각하기
- 클래스 사이의 관계에도 관심을 기울여보기
  - A는 B이다
  - A에는 B가 있다 // Duck에는 Fly, Quack 이라는 행동이 있다
  - A가 B를 구현한다 // FlyBehavior를 FlyWithWings가 구현

# 두 클래스를 합치는 방법

- A에는 B가 있다 관계
  - 각 오리에는 FlyBehavior, QuackBehavior가 있으며 각각 나는 행동과 꽥꽥거리는 행동을 위임 받음
  - 이런 식으로 두 클래스를 합치는 것을 구성(composition)을 이용한다고 함
  - 오리 클래스에서는 행동을 상속받는 대신, 올바른 행동 객체로 구성되어 행동을 부여 받음(행동 X, 객체를 부여)
  - 디자인 원칙: 상속보다는 구성을 활용한다

# 전략 패턴

- 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다.
  전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경 가능
